<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.29">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Nora Elliott">
<meta name="dcterms.date" content="2025-04-07">
<meta name="description" content="This post explores the strengths and shortcomings of AI chatbots compared to human agents in customer service, revealing when speed matters vs when empathy makes the difference.">

<title>Chatbot vs.&nbsp;Human: Who Wins at Customer Service? – My Explorations with LLMs</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-0815c480559380816a4d1ea211a47e91.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-579d6c4618e5a59810377e89491554d5.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">My Explorations with LLMs</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Chatbot vs.&nbsp;Human: Who Wins at Customer Service?</h1>
                  <div>
        <div class="description">
          This post explores the strengths and shortcomings of AI chatbots compared to human agents in customer service, revealing when speed matters vs when empathy makes the difference.
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">Logic</div>
                <div class="quarto-category">NLPs</div>
                <div class="quarto-category">Marketing</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Nora Elliott </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">April 7, 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="chatbot-or-human-who-handles-customer-service-better" class="level1">
<h1>Chatbot or Human, Who Handles Customer Service Better?</h1>
<p>In the age of instant replies and 24/7 support, customer service has entered a new frontier. AI powered chatbots are no longer just simple FAQ responders, they can troubleshoot issues, process refunds, and even mimic conversational tone. But can they actually match, or beat, human representatives when it comes to resolving real customer complaints?</p>
<p>To find out, we explore the growing role of chatbots in customer service, and see how they stack up against their human counterparts in one of the most emotionally charged parts of business: customer complaints.</p>
<section id="the-rise-of-the-chatbot-in-customer-service" class="level2">
<h2 class="anchored" data-anchor-id="the-rise-of-the-chatbot-in-customer-service">The Rise of the Chatbot in Customer Service</h2>
<p><img src="Post16_files/figure-html/488094ad-f7a1-48dd-bb95-34076b2873c5-6-fcb97f79-eee1-475a-9dad-2429119cce43.png" class="img-fluid"></p>
<p>Popular platforms like Zendesk, Intercom, and Drift are using AI chatbots to triage tickets, automate basic requests, and resolve common issues in seconds. According to a report by Gartner, by 2027, chatbots are expected to become the primary customer service channel for about a quarter of all businesses.</p>
<section id="but-are-they-truly-better-or-just-cheaper" class="level4">
<h4 class="anchored" data-anchor-id="but-are-they-truly-better-or-just-cheaper">But are they truly better, or just cheaper?</h4>
</section>
</section>
<section id="how-chatbots-handle-complaints-a-real-test" class="level2">
<h2 class="anchored" data-anchor-id="how-chatbots-handle-complaints-a-real-test">How Chatbots Handle Complaints: A Real Test</h2>
<p><img src="Post16_files/figure-html/488094ad-f7a1-48dd-bb95-34076b2873c5-2-62484625-4388-4b1b-b06a-de8af5526b61.jpg" class="img-fluid"></p>
<p>Let’s take a scenario and run it through an AI chatbot (GPT) to see it performs.</p>
<p>Scenario: A customer receives a defective pair of shoes and wants a refund. The shoes were a birthday gift, and the customer is upset.</p>
<p>Chatbot Response: “Hello! I understand you’re unhappy with your recent order. Please allow me to assist you. I have initiated a refund and can help with a replacement. For expedited shipping, please type ‘FASTSHIP’. Apologies for the inconvenience.” The chatbot is efficient and gets the job done, but it can’t add emotional intelligence, personalization, or empathy. That’s a huge factor when a customer is upset or disappointed.</p>
<p>*There may be specific chatbots more equipped to handle issues of customer servoce better/specific companies may have their own chatbots for purposes that align with their customers needs</p>
</section>
<section id="where-chatbots-excel" class="level2">
<h2 class="anchored" data-anchor-id="where-chatbots-excel">Where Chatbots Excel</h2>
<p><img src="Post16_files/figure-html/488094ad-f7a1-48dd-bb95-34076b2873c5-4-a6512748-7bbf-4774-a323-e053f6f2f08c.jpg" class="img-fluid"></p>
<p>Despite their emotional limitations, chatbots have undeniable strengths:</p>
<section id="speed-availability" class="level5">
<h5 class="anchored" data-anchor-id="speed-availability">1. Speed &amp; Availability</h5>
<p>AI chatbots can respond instantly, at any hour, in any time zone. No waiting on hold or navigating complex phone trees.</p>
</section>
<section id="cost-efficiency" class="level5">
<h5 class="anchored" data-anchor-id="cost-efficiency">2. Cost Efficiency</h5>
<p>They handle thousands of inquiries simultaneously, reducing the need for large customer service teams and cutting operational costs.</p>
</section>
<section id="consistency" class="level5">
<h5 class="anchored" data-anchor-id="consistency">3. Consistency</h5>
<p>Unlike human reps who might have bad days or inconsistent training, chatbots deliver the same tone and policy compliant responses every time.</p>
</section>
<section id="task-automation" class="level5">
<h5 class="anchored" data-anchor-id="task-automation">4. Task Automation</h5>
<p>For straightforward tasks, like checking order status, resetting passwords, or initiating returns, bots are hard to beat.</p>
</section>
<section id="multilingual-capabilities" class="level5">
<h5 class="anchored" data-anchor-id="multilingual-capabilities">5. Multilingual Capabilities</h5>
<p>Advanced LLMs can translate and reply in multiple languages instantly, widening accessibility for global customers.</p>
</section>
</section>
<section id="where-chatbots-fall-short" class="level2">
<h2 class="anchored" data-anchor-id="where-chatbots-fall-short">Where Chatbots Fall Short</h2>
<p><img src="Post16_files/figure-html/488094ad-f7a1-48dd-bb95-34076b2873c5-5-bce1bd0c-ed1f-4296-9fbf-02846ba18dd8.jpg" class="img-fluid"></p>
<p>Still, bots are far from perfect and some gaps are hard to ignore.</p>
<section id="lack-of-empathy" class="level5">
<h5 class="anchored" data-anchor-id="lack-of-empathy">1. Lack of Empathy</h5>
<p>Even the most sophisticated chatbot can struggle to read emotional tone or respond with genuine care.</p>
</section>
<section id="complex-issue-resolution" class="level5">
<h5 class="anchored" data-anchor-id="complex-issue-resolution">2. Complex Issue Resolution</h5>
<p>When complaints involve nuanced problems—like mismatched product expectations or unclear billing issues—humans are better equipped to investigate and improvise.</p>
</section>
<section id="frustration-with-loops" class="level5">
<h5 class="anchored" data-anchor-id="frustration-with-loops">3. Frustration with Loops</h5>
<p>We’ve all been there: trapped in a chatbot loop, typing “agent” repeatedly, only to get rerouted. When bots fail, they fail hard.</p>
</section>
<section id="limited-escalation-power" class="level5">
<h5 class="anchored" data-anchor-id="limited-escalation-power">4. Limited Escalation Power</h5>
<p>A chatbot might not have the authority to offer goodwill gestures (discounts, rush shipping, apologies with personal touches) that humans can.</p>
</section>
<section id="brand-reputation-risks" class="level5">
<h5 class="anchored" data-anchor-id="brand-reputation-risks">5. Brand Reputation Risks</h5>
<p>A robotic or insensitive response to a delicate situation can make a customer feel unheard, or worse—insulted. That can go viral fast.</p>
</section>
<section id="human-agents-still-the-gold-standard" class="level3">
<h3 class="anchored" data-anchor-id="human-agents-still-the-gold-standard">Human Agents: Still the Gold Standard?</h3>
<p><img src="Post16_files/figure-html/488094ad-f7a1-48dd-bb95-34076b2873c5-1-3285b9fa-fcd8-4b77-8c4f-42298651ff02.png" class="img-fluid"></p>
<p>Human representatives are still the benchmark for high quality, emotionally intelligent service. They offer * Empathy and active listening * Creative problem-solving * Personal connection that builds loyalty * Judgment calls that build trust</p>
<p>In industries where relationships matter, like hospitality, healthcare, or luxury retail, human reps often make the difference between a one time buyer and a lifelong customer.</p>
<p>So…Who Handles It Better? It depends on the context.</p>
<ul>
<li>For fast, low stakes inquiries (order tracking, return requests, FAQs): Chatbots win for speed and scalability.</li>
<li>For emotionally sensitive or high stakes issues (product failures, service dissatisfaction, complaints): Humans win with empathy and nuance.</li>
<li>For hybrid service models (chatbot triage + human escalation): Everyone wins.</li>
</ul>
<section id="the-best-customer-service-strategies-dont-treat-it-as-a-competition-but-a-collaboration.-chatbots-handle-the-basics-and-reduce-wait-times-while-humans-step-in-when-care-creativity-or-connection-are-needed." class="level4">
<h4 class="anchored" data-anchor-id="the-best-customer-service-strategies-dont-treat-it-as-a-competition-but-a-collaboration.-chatbots-handle-the-basics-and-reduce-wait-times-while-humans-step-in-when-care-creativity-or-connection-are-needed.">The best customer service strategies don’t treat it as a competition but a collaboration. Chatbots handle the basics and reduce wait times, while humans step in when care, creativity, or connection are needed.</h4>
<p><img src="Post16_files/figure-html/488094ad-f7a1-48dd-bb95-34076b2873c5-3-a33ca864-9b2a-413b-b7ab-964609346888.webp" class="img-fluid"></p>
</section>
</section>
</section>
<section id="the-future-of-customer-service-collaboration-not-replacement" class="level2">
<h2 class="anchored" data-anchor-id="the-future-of-customer-service-collaboration-not-replacement">The Future of Customer Service: Collaboration, Not Replacement</h2>
<p>Rather than asking chatbot or human?, forward thinking companies are designing human+AI systems. Chatbots can now flag customer emotions through sentiment analysis, then route frustrated customers to human agents with full conversation context. AI can also assist human reps, suggesting responses, analyzing tone, or pulling up account data in real time.</p>
<p>And with generative AI improving daily, future bots may sound indistinguishable from humans. But until then, empathy remains a uniquely human superpower.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/noraelli\.github\.io\/comm4190_S25_Using_LLMs_Blog\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>